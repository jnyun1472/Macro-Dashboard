<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Macro Dashboard (Numbers Only)</title>
  <!-- Tailwind (프로토타입용 CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-neutral-50 text-neutral-900">
  <div class="max-w-5xl mx-auto p-4 sm:p-6">
    <!-- 상단: 제목 / API 키 입력 -->
    <div class="w-full flex flex-col md:flex-row gap-3 items-start md:items-center justify-between p-4 bg-white/70 backdrop-blur rounded-xl shadow">
      <div>
        <h1 class="text-xl font-bold">Macro Dashboard</h1>
        <p class="text-sm text-neutral-500">차트 없이 숫자만 간단히 표시합니다. (FRED API 키 필요)</p>
      </div>
      <div class="flex items-center gap-2 w-full md:w-auto">
        <input id="apiKeyInput" type="password"
               class="w-full md:w-80 px-3 py-2 rounded-lg border border-neutral-300 bg-white"
               placeholder="FRED API Key" />
        <button id="saveBtn"
                class="px-4 py-2 rounded-lg bg-black text-white hover:opacity-90">저장</button>
        <button id="refreshBtn"
                class="px-4 py-2 rounded-lg bg-neutral-800 text-white hover:opacity-90">새로고침</button>
      </div>
    </div>

    <!-- 상태 표시 -->
    <div class="mt-3 flex items-center justify-between">
      <div id="statusText" class="text-sm text-neutral-500">대기 중…</div>
      <div id="lastUpdated" class="text-sm text-neutral-500"></div>
    </div>

    <!-- API 키 안내 -->
    <div id="noKeyBox" class="hidden mt-4 p-4 rounded-xl bg-amber-50 border border-amber-200 text-amber-900">
      FRED API 키를 입력하고 <b>저장</b>을 누른 뒤 <b>새로고침</b>을 누르세요. (키는 브라우저에만 저장됩니다)
    </div>

    <!-- 에러 박스 -->
    <div id="errorBox" class="hidden mt-4 p-3 rounded-lg bg-red-100 text-red-800"></div>

    <!-- 지표 테이블 -->
    <div class="mt-5 overflow-x-auto">
      <table class="w-full min-w-[720px] bg-white rounded-xl shadow border border-neutral-200">
        <thead>
          <tr class="text-xs text-neutral-500">
            <th class="text-left px-3 py-2">Indicator</th>
            <th class="text-right px-3 py-2">Latest</th>
            <th class="text-right px-3 py-2">Δ 1m</th>
            <th class="text-right px-3 py-2">Δ 3m</th>
            <th class="text-right px-3 py-2">As of</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>

    <div class="mt-4 text-xs text-neutral-500">
      Source: FRED API. 표시 값은 최신 관측치 기준이며, 월/주/일 자료는 서로 다른 빈도를 가질 수 있습니다.
    </div>
  </div>

  <script type="module">
    // ===== 설정 =====
    const START_DATE = "2019-01-01";
    const LS_KEY = "FRED_API_KEY";

    // 최소 셋으로 시작 (원하시면 나중에 추가)
    const INDICATORS = [
      // label, desc, key, type('level'|'yoy'), isPercent
      { key: "CPIAUCSL", label: "CPI YoY", desc: "미국 CPI (전년동월 대비)", type: "yoy", isPercent: true },
      { key: "DGS10",    label: "10Y Yield", desc: "미 국채 10년물 수익률(%)", type: "level", isPercent: true },
      { key: "SP500",    label: "S&P 500", desc: "S&P 500 지수(가격)", type: "level", isPercent: false },
      { key: "GOLDPMGBD228NLBM", label: "Gold PM Fix", desc: "런던 금(오전 고시가, $/oz)", type: "level", isPercent: false },
      { key: "DTWEXBGS", label: "Dollar Index", desc: "미 달러(TW) 지수", type: "level", isPercent: false },
      { key: "PAYEMS",   label: "NFP", desc: "비농업 부문 고용(천 명)", type: "level", isPercent: false },
      { key: "ICSA",     label: "Initial Claims", desc: "신규 실업수당 청구(주간)", type: "level", isPercent: false },
    ];

    // ===== 유틸 =====
    const $ = (sel) => document.querySelector(sel);
    function fmt(num, digits = 2) {
      if (num === null || num === undefined || Number.isNaN(num)) return "–";
      return Number(num).toLocaleString(undefined, { maximumFractionDigits: digits, minimumFractionDigits: digits });
    }
    function fmtDate(dStr) {
      if (!dStr) return "";
      const d = new Date(dStr);
      if (Number.isNaN(d.getTime())) return dStr;
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      return `${yyyy}-${mm}-${dd}`;
    }
    function days(n) { return 24 * 60 * 60 * 1000 * n; }

    function valueAtOrBefore(observations, targetDate) {
      for (let i = observations.length - 1; i >= 0; i--) {
        const d = new Date(observations[i].date);
        if (d.getTime() <= targetDate.getTime()) return observations[i].value;
      }
      return null;
    }
    function yoyFrom(observations) {
      if (!observations || observations.length < 13) return null;
      const last = observations[observations.length - 1];
      const lastD = new Date(last.date);
      let prev12 = null;
      for (let i = observations.length - 2; i >= 0; i--) {
        const d = new Date(observations[i].date);
        if (d.getUTCFullYear() === lastD.getUTCFullYear() - 1 && d.getUTCMonth() === lastD.getUTCMonth()) {
          prev12 = observations[i].value;
          break;
        }
      }
      if (prev12 === null) return null;
      return (last.value / prev12 - 1) * 100;
    }

    async function fetchFredSeries(seriesId, apiKey, start = START_DATE) {
      const url = "https://api.stlouisfed.org/fred/series/observations"
        + "?series_id=" + encodeURIComponent(seriesId)
        + "&api_key=" + encodeURIComponent(apiKey)
        + "&file_type=json"
        + "&observation_start=" + encodeURIComponent(start);
      const res = await fetch(url);
      if (!res.ok) throw new Error("FRED fetch failed: " + seriesId);
      const json = await res.json();
      const obs = (json.observations || [])
        .filter(o => o.value !== "." && o.value !== null)
        .map(o => ({ date: o.date, value: parseFloat(o.value) }))
        .filter(o => !Number.isNaN(o.value));
      return obs;
    }

    function computeDeltas(observations, mode /* 'level'|'yoy' */) {
      if (!observations || !observations.length) {
        return { latest: null, d1m: null, d3m: null, asOf: null };
      }
      const latest = observations[observations.length - 1];
      const lastDate = new Date(latest.date);

      if (mode === "yoy") {
        // YoY는 델타 대신 %만 표시
        return {
          latest: yoyFrom(observations),
          d1m: null,
          d3m: null,
          asOf: latest.date,
          isPercent: true
        };
      }

      const v1m = valueAtOrBefore(observations, new Date(lastDate.getTime() - days(30)));
      const v3m = valueAtOrBefore(observations, new Date(lastDate.getTime() - days(90)));
      return {
        latest: latest.value,
        d1m: v1m !== null ? latest.value - v1m : null,
        d3m: v3m !== null ? latest.value - v3m : null,
        asOf: latest.date
      };
    }

    // ===== 렌더링 =====
    function renderRow(tbody, def, metrics) {
      const tr = document.createElement("tr");
      tr.className = "border-t border-neutral-100 hover:bg-neutral-50";
      const latestStr = (def.isPercent || metrics.isPercent)
        ? (metrics.latest === null ? "–" : `${Number(metrics.latest).toFixed(1)}%`)
        : fmt(metrics.latest);

      const d1mStr = metrics.d1m === null ? "–" : (def.isPercent ? `${Number(metrics.d1m).toFixed(2)}` : fmt(metrics.d1m));
      const d3mStr = metrics.d3m === null ? "–" : (def.isPercent ? `${Number(metrics.d3m).toFixed(2)}` : fmt(metrics.d3m));
      const d1mClass = metrics.d1m > 0 ? "text-emerald-600" : metrics.d1m < 0 ? "text-rose-600" : "";
      const d3mClass = metrics.d3m > 0 ? "text-emerald-600" : metrics.d3m < 0 ? "text-rose-600" : "";

      tr.innerHTML = `
        <td class="px-3 py-3">
          <div class="font-medium">${def.label}</div>
          <div class="text-xs text-neutral-500">${def.desc}</div>
        </td>
        <td class="px-3 py-3 text-right font-semibold">${latestStr}</td>
        <td class="px-3 py-3 text-right font-semibold ${d1mClass}">${d1mStr}</td>
        <td class="px-3 py-3 text-right font-semibold ${d3mClass}">${d3mStr}</td>
        <td class="px-3 py-3 text-right text-xs text-neutral-500">${fmtDate(metrics.asOf)}</td>
      `;
      tbody.appendChild(tr);
    }

    async function loadAll() {
      const apiKey = localStorage.getItem(LS_KEY) || "";
      const status = $("#statusText");
      const errorBox = $("#errorBox");
      const noKeyBox = $("#noKeyBox");
      const tbody = $("#tbody");
      const lastUpdated = $("#lastUpdated");

      $("#apiKeyInput").value = apiKey;
      tbody.innerHTML = "";
      errorBox.classList.add("hidden");
      errorBox.textContent = "";

      if (!apiKey) {
        noKeyBox.classList.remove("hidden");
        status.textContent = "API 키를 입력하세요.";
        lastUpdated.textContent = "";
        return;
      } else {
        noKeyBox.classList.add("hidden");
      }

      try {
        status.textContent = "불러오는 중…";
        const all = await Promise.all(INDICATORS.map(d => fetchFredSeries(d.key, apiKey)));
        all.forEach((obs, i) => {
          const def = INDICATORS[i];
          const m = computeDeltas(obs, def.type);
          renderRow(tbody, def, m);
        });
        status.textContent = "완료";
        lastUpdated.textContent = new Date().toLocaleString(undefined, { hour12: false });
      } catch (e) {
        status.textContent = "오류";
        errorBox.textContent = "데이터 로드 중 오류: " + (e.message || String(e)) + " (API 키와 네트워크를 확인하세요)";
        errorBox.classList.remove("hidden");
      }
    }

    // ===== 이벤트 =====
    $("#saveBtn").addEventListener("click", () => {
      const v = $("#apiKeyInput").value.trim();
      if (!v) return;
      localStorage.setItem(LS_KEY, v);
      alert("API 키를 저장했습니다. 이제 '새로고침'을 눌러 데이터를 불러오세요.");
    });
    $("#refreshBtn").addEventListener("click", loadAll);

    // 초기 로드
    loadAll();
  </script>
</body>
</html>
